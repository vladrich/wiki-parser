/**
* JavaCC Wiki grammar file
*/

/** Tests 

__a__ ''b'' ^^c^^
__a__
''a''
^^a^^
! __a ''b'' c__ d!
* a
** a
*** a
* a 
---
  --- ! cool __ stuff ''rocks'' __
a//b//c//d//e
! __a // ''b // '' c // __ d!
Wannabe a wiki parser // must go on with that paragraph //
|a|b|c|
|a|b|c|
|a|b|c|
|''a'' __a''a''__|a|

*/

PARSER_BEGIN(WikiParser)

package org.wyona.wiki;

import java.util.Iterator;
import java.util.Set;

public class WikiParser {	
	
	// needed for XML Header
	static boolean show = true;

    public static void main(String args[]) {

        System.out.println("Enter Wiki-Markup:");
        
        WikiParser t = new WikiParser(System.in);
        try {        	
            SimpleNode n = t.WikiBody();
            //n.dump("");            
			debugNodeTree(n, 0);            
        } catch (Exception e) {        	
            System.out.println("Oops.");
            System.out.println(e.getMessage());
            e.printStackTrace();            
        }
    } 
    
    /**
    * 	This method will output the node tree to the console.
    */
    public static void debugNodeTree(SimpleNode node, int depth) {
  		SimpleNode n = node;
  		for (int i=0; i<depth; i++) 
  			System.out.print(" ");
  			System.out.print(n.toString());
        	if (!node.optionMap.isEmpty()) {
            Set keySet = node.optionMap.keySet();
            Iterator kit = keySet.iterator();
            while (kit.hasNext()) {
                Object option = kit.next();
                Object value = node.optionMap.get(option);
                System.out.print(":" + option.toString() + "=" + value.toString());
            }
        }        
        System.out.println();
        if (n.jjtGetNumChildren() > 0) {            
            for (int i = 0; i < n.jjtGetNumChildren(); i++) {
                debugNodeTree((SimpleNode)node.jjtGetChild(i), depth + 1);
            }            
        }                
    }
    
    /**
    * This method generates XML output.
    */
    public static void traverseXML(SimpleNode node, int depth) {
    	
    	
    	SimpleNode n = node;
		
		// display once header!
		if (show) {
			System.out.println("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
			show = false;
		}
		
		
    	for (int i=0; i<depth; i++)
  			System.out.print(" ");
  			
  			if (n.jjtGetNumChildren() > 0) {
  			System.out.print("<" + n.toString() + ">");
  			}
  			else {
  				System.out.print("<" + n.toString() + " value = ");
  			}
  			
  			if (!node.optionMap.isEmpty()) {
            Set keySet = node.optionMap.keySet();
            Iterator kit = keySet.iterator();
            	while (kit.hasNext()) {
                	Object option = kit.next();
	                Object value = node.optionMap.get(option);
	                System.out.print("\"" + value.toString()+ "\"" + "/>");
    	        }
    		}
  		
  		System.out.println();
        if (n.jjtGetNumChildren() > 0) {

            for (int i = 0; i < n.jjtGetNumChildren(); i++) {
                traverseXML((SimpleNode)node.jjtGetChild(i), depth + 1);
            }         
           	for (int i=0; i<depth; i++)
  			System.out.print(" ");
  			
			System.out.print("</" + n.toString() + ">" +"\n");
        }
    }
}

PARSER_END(WikiParser)

/** Tokens */

<DEFAULT> 
TOKEN: {
	<BOLD: "__"> : DEFAULT_NOTAGS
}

<DEFAULT> 
TOKEN: {
	<ITALIC: "''"> : DEFAULT_NOTAGS
}

<DEFAULT> 
TOKEN: {
	<UNDERLINE: "^^"> : DEFAULT_NOTAGS
}

<DEFAULT_NOTAGS>
TOKEN: {
	<NOTAGS_EOL: "\r" | "\r\n" | "\n"> : DEFAULT
|	<NOTAGS_BOLD: <BOLD>>
|	<NOTAGS_ITALIC: <ITALIC>>
|	<NOTAGS_UNDERLINE: <UNDERLINE>>
|   <NOTAGS_FORCE_NEWLINE: <FORCE_NEWLINE>>
|	<NOTAGS_ANY_CHAR: ~[]>
}

<DEFAULT>
TOKEN: {
	<HRULE: "---">	
}

<DEFAULT>
TOKEN: {
	<TABLE: "|"> : IN_TABLE		
}

<IN_TABLE>
TOKEN: {
	<TABLE_EOL: "\r" | "\r\n" | "\n"> : DEFAULT
|	<TABLE_TABLE: "|">
|	<TABLE_BOLD: <BOLD>>
|	<TABLE_ITALIC: <ITALIC>>
|	<TABLE_UNDERLINE: <UNDERLINE>>
|   <TABLE_FORCE_NEWLINE: <FORCE_NEWLINE>>
|	<TABLE_ANY_CHAR: ~[]> 
}

<DEFAULT>
TOKEN: {
	<LIST: "*"> : IN_LIST
}

<IN_LIST>
TOKEN: {
	<LIST_EOL: "\r" | "\r\n" | "\n"> : DEFAULT
|	<LIST_LIST: <LIST>>
|	<LIST_BOLD: <BOLD>>
|	<LIST_ITALIC: <ITALIC>>
|	<LIST_UNDERLINE: <UNDERLINE>>
|   <LIST_FORCE_NEWLINE: <FORCE_NEWLINE>>
|	<LIST_ANY_CHAR: ~[]>
}

<DEFAULT> 
TOKEN: {
	<TITLE: "!"> : IN_TITLE
}

<IN_TITLE>
TOKEN: {
	<TITLE_EOL: "\r" | "\r\n" | "\n"> : DEFAULT
|	<TITLE_BOLD: <BOLD>>
|	<TITLE_ITALIC: <ITALIC>>
|	<TITLE_UNDERLINE: <UNDERLINE>>
|   <TITLE_FORCE_NEWLINE: <FORCE_NEWLINE>>
|	<TITLE_ANY_CHAR: ~[]>
}

<DEFAULT> 
TOKEN: {
	<START_PLAIN: "{{"> : IN_PLAIN
}

<IN_PLAIN>
TOKEN: {
	<END_PLAIN: "}}"> : DEFAULT
|	<PLAIN_ANY_CHAR: ~[]>
}

<DEFAULT> 
TOKEN: {
	<FORCE_NEWLINE: "//">
}

<DEFAULT>
SKIP: {
	<TAB: "\t">	
}

<DEFAULT> 
TOKEN: {
	<EOL: "\r" | "\r\n" | "\n">
}

<DEFAULT>
TOKEN: {
	<ANY_CHAR: ~[]>
}


/** Actions */

SimpleNode WikiBody() : {}
{
	(
		LOOKAHEAD(2)
		Paragraph() 	|
		<EOL>			| 
		<NOTAGS_EOL>
	)*
	<EOF>
	{ return jjtThis; }
}

/** Paragraph */
 
void Paragraph() : {}
{
	(
		LOOKAHEAD(2) 
		Plain()			| 
		Text()			| 
		Bold()			| 
		Italic()		| 
		Underline() 	| 
		ForceNewline()	| 
		Title()			|
		List()			|
		Hrule()			|
		Table()
	)+
}

void Bold() : {} 
{
	(
		<TITLE_BOLD>	| 
		<BOLD>			| 
		<NOTAGS_BOLD>	| 
		<LIST_BOLD>		| 
		<TABLE_BOLD>
	) 
	(
		Text() | ForceNewline() | Italic() | Underline()
	)+
	(
		<TITLE_BOLD>	| 
		<NOTAGS_BOLD>	| 
		<LIST_BOLD>		| 
		<TABLE_BOLD>
	)
}

void Italic() : {}
{
	(
		<TITLE_ITALIC>	| 
		<ITALIC> 		| 
		<NOTAGS_ITALIC> | 
		<LIST_ITALIC>	| 
		<TABLE_ITALIC>
	) 
	(
		Text() | ForceNewline() | Bold() | Underline()
	)+
	(
		<TITLE_ITALIC>	| 
		<NOTAGS_ITALIC> | 
		<LIST_ITALIC>	| 
		<TABLE_ITALIC>
	)
} 

void Underline() : {}
{
	(
		<TITLE_UNDERLINE>	| 
		<UNDERLINE>			| 
		<NOTAGS_UNDERLINE>	| 
		<LIST_UNDERLINE>	| 
		<TABLE_UNDERLINE>
	) 
	(
		Text() | ForceNewline() | Italic()| Bold()
	)+
	(
		<TITLE_UNDERLINE>	|
		<NOTAGS_UNDERLINE>	| 
		<LIST_UNDERLINE>	| 
		<TABLE_UNDERLINE>
	)
}

/** Table */

void Table() : {}
{
	(
		LOOKAHEAD(2) 
		TableRow()
	)+ 
}

void TableRow(): {}
{
	(
		LOOKAHEAD(2) 
		TableCol()
	)+ 	
	<TABLE_TABLE> <TABLE_EOL>	
}

void TableCol() : {}
{
	(
		<TABLE> | 
		<TABLE_TABLE>
	) 
	(
		LOOKAHEAD(2) 
		Text()		| 
		Bold()		| 
		Italic()	| 
		Underline()
	)+ 
}


/** List */

void List() : 
{
	int listDepth = 1;
}
{
	<LIST> 
	[
		LOOKAHEAD(2) 
		(
			<LIST_LIST> { listDepth += 1; }
		)+
	] 
	(
		LOOKAHEAD(2)
		Text()			|
		ForceNewline()	| 
		Bold()			| 
		Italic()		| 
		Underline()
	)+
	<LIST_EOL>
	{ jjtThis.setOption("depth", listDepth); }
}

/** Plaintext */

void Plain() : {}
{
	<START_PLAIN> 
	(
		LOOKAHEAD(2) 
		PlainText()
	)* 
	<END_PLAIN>	
}

void PlainText() : 
{
	Token t;
}
{
	t = <PLAIN_ANY_CHAR>	{ jjtThis.setOption("value", t.image); } 		
}

/** Horizontal Rule */

void Hrule() : {}
{
	<HRULE>	
}

/** Title */

void Title() : {}
{
	<TITLE> 
	(
		LOOKAHEAD(2)
		Text()			|
		ForceNewline()	| 
		Bold()			| 
		Italic()		| 
		Underline()
	)+
	<TITLE_EOL>
}


/** State spanning actions */

void Text() : 
{
	Token t;
}
{
	t = <NOTAGS_ANY_CHAR>	{ jjtThis.setOption("value", t.image); } |
	t = <LIST_ANY_CHAR>		{ jjtThis.setOption("value", t.image); } | 
	t = <TITLE_ANY_CHAR>	{ jjtThis.setOption("value", t.image); } | 
	t = <TABLE_ANY_CHAR>	{ jjtThis.setOption("value", t.image); } |
	t = <ANY_CHAR>			{ jjtThis.setOption("value", t.image); } 		
}

void ForceNewline() : {}
{
	<TITLE_FORCE_NEWLINE>	| 
	<NOTAGS_FORCE_NEWLINE>	| 
	<LIST_FORCE_NEWLINE>	|
	<TABLE_FORCE_NEWLINE>	|
	<FORCE_NEWLINE>	
}