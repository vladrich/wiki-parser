/**
* JavaCC Wiki grammar file
*/

/** Tests 

__a__ ''b'' ^^c^^
__a__
''a''
^^a^^
! __a ''b'' c__ d!
* a
** a
*** a
* a 
---
  --- ! cool __ stuff ''rocks'' __
a//b//c//d//e
! __a // ''b // '' c // __ d!
Wannabe a wiki parser // must go on with that paragraph //
|a|b|c|
|a|b|c|
|a|b|c|
|''a'' __a''a''__|a|

*/

PARSER_BEGIN(WikiParser)

package org.wyona.wiki;

import java.util.Iterator;
import java.util.Set;

public class WikiParser {	
	
	// needed for XML Header
	static boolean show = true;

    public static void main(String args[]) {

        System.out.println("Enter Wiki-Markup:");
        
        WikiParser t = new WikiParser(System.in);
        try {        	
            SimpleNode n = t.WikiBody();
            //n.dump("");            
			debugNodeTree(n, 0);            
        } catch (Exception e) {        	
            System.out.println("Oops.");
            System.out.println(e.getMessage());
            e.printStackTrace();            
        }
    } 
    
    /**
    * 	This method will output the node tree to the console.
    */
    public static void debugNodeTree(SimpleNode node, int depth) {
  		SimpleNode n = node;
  		for (int i=0; i<depth; i++) 
  			System.out.print(" ");
  			System.out.print(n.toString());
        	if (!node.optionMap.isEmpty()) {
            Set keySet = node.optionMap.keySet();
            Iterator kit = keySet.iterator();
            while (kit.hasNext()) {
                Object option = kit.next();
                Object value = node.optionMap.get(option);
                System.out.print(":" + option.toString() + "=" + value.toString());
            }
        }        
        System.out.println();
        if (n.jjtGetNumChildren() > 0) {            
            for (int i = 0; i < n.jjtGetNumChildren(); i++) {
                debugNodeTree((SimpleNode)node.jjtGetChild(i), depth + 1);
            }            
        }                
    }
    
    /**
    * This method generates XML output.
    */
    public static void traverseXML(SimpleNode node, int depth) {    	    	
    	SimpleNode n = node;
		
		// display once header!
		if (show) {
			System.out.println("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
			show = false;
		}
				
    	for (int i=0; i<depth; i++)
  			System.out.print(" ");    	
    	System.out.print("<" + n.toString());  		
  		if (!node.optionMap.isEmpty()) {
    	    Set keySet = node.optionMap.keySet();
         	Iterator kit = keySet.iterator();
            while (kit.hasNext()) {
               	Object option = kit.next();
	            Object value = node.optionMap.get(option);
				System.out.print(" " + option.toString() + "=" + "\"" + value.toString() + "\"");
    		}
    	}  		
    	if (n.jjtGetNumChildren() > 0) {
    		System.out.println(">"); 
            for (int i = 0; i < n.jjtGetNumChildren(); i++) 
                traverseXML((SimpleNode)node.jjtGetChild(i), depth + 1);              			
           	for (int i = 0; i < depth; i++)
	  			System.out.print(" ");    	
	    	System.out.println("</" + n.toString() + ">");
        } else {
        	System.out.println("/>"); 
    	}
    }
}

PARSER_END(WikiParser)

/** Tokens */

<DEFAULT> 
TOKEN: {
	<BOLD: "__"> : DEFAULT_NOTAGS
}

<DEFAULT> 
TOKEN: {
	<ITALIC: "''"> : DEFAULT_NOTAGS
}

<DEFAULT> 
TOKEN: {
	<UNDERLINE: "^^"> : DEFAULT_NOTAGS
}

<DEFAULT_NOTAGS>
TOKEN: {
	<NOTAGS_EOL: "\r" | "\r\n" | "\n"> : DEFAULT
|	<NOTAGS_BOLD: <BOLD>>
|	<NOTAGS_ITALIC: <ITALIC>>
|	<NOTAGS_UNDERLINE: <UNDERLINE>>
|   <NOTAGS_FORCE_NEWLINE: <FORCE_NEWLINE>>
|	<NOTAGS_ANY_CHAR: ~[]>
}

<DEFAULT>
TOKEN: {
	<HRULE: "---">	
}

<DEFAULT>
TOKEN: {
	<TABLE: "|"> : IN_TABLE		
}

<IN_TABLE>
TOKEN: {
	<TABLE_EOL: "\r" | "\r\n" | "\n"> : DEFAULT
|	<TABLE_TABLE: "|">
|	<TABLE_BOLD: <BOLD>>
|	<TABLE_ITALIC: <ITALIC>>
|	<TABLE_UNDERLINE: <UNDERLINE>>
|   <TABLE_FORCE_NEWLINE: <FORCE_NEWLINE>>
|	<TABLE_ANY_CHAR: ~[]> 
}

<DEFAULT>
TOKEN: {
	<LIST: "*"> : IN_LIST
}

<IN_LIST>
TOKEN: {
	<LIST_EOL: "\r" | "\r\n" | "\n"> : DEFAULT
|	<LIST_LIST: <LIST>>
|	<LIST_BOLD: <BOLD>>
|	<LIST_ITALIC: <ITALIC>>
|	<LIST_UNDERLINE: <UNDERLINE>>
|   <LIST_FORCE_NEWLINE: <FORCE_NEWLINE>>
|	<LIST_ANY_CHAR: ~[]>
}

<DEFAULT> 
TOKEN: {
	<TITLE: "!"> : IN_TITLE
}

<DEFAULT> 
TOKEN: {
	<MAINTITLE: "!!"> : IN_TITLE
}

<DEFAULT> 
TOKEN: {
	<MAINMAINTITLE: "!!!"> : IN_TITLE
}


<IN_TITLE>
TOKEN: {
	<TITLE_EOL: "\r" | "\r\n" | "\n"> : DEFAULT
|	<TITLE_BOLD: <BOLD>>
|	<TITLE_ITALIC: <ITALIC>>
|	<TITLE_UNDERLINE: <UNDERLINE>>
|   <TITLE_FORCE_NEWLINE: <FORCE_NEWLINE>>
|	<TITLE_ANY_CHAR: ~[]>
}

<DEFAULT> 
TOKEN: {
	<LINK: "["> : IN_LINK
}

<IN_LINK>
TOKEN: {
	<LINK_EOL: "\r" | "\r\n" | "\n"> : DEFAULT
|	<LINK_END: "]">
|	<LINK_SEPARATOR: "|">
|	<LINK_ANY_CHAR: ~[]>
}

<DEFAULT> 
TOKEN: {
	<START_PLAIN: "{{"> : IN_PLAIN
}

<IN_PLAIN>
TOKEN: {
	<END_PLAIN: "}}"> : DEFAULT
|	<PLAIN_ANY_CHAR: ~[]>
}

<DEFAULT> 
TOKEN: {
	<FORCE_NEWLINE: "\\\\">
}

<DEFAULT>
SKIP: {
	<TAB: "\t">	
}

<DEFAULT> 
TOKEN: {
	<EOL: "\r" | "\r\n" | "\n">
}

<DEFAULT>
TOKEN: {
	<ANY_CHAR: ~[]>
}


/** Actions */

SimpleNode WikiBody() : {}
{
	(
		LOOKAHEAD(2)
		Paragraph() 	|
		<EOL>			| 
		<NOTAGS_EOL>
	)*
	<EOF>
	{ return jjtThis; }
}

/** Paragraph */
 
void Paragraph() : {}
{
	(
		LOOKAHEAD(2) 
		Plain()			| 
		Text()			| 
		Bold()			| 
		Italic()		| 
		Underline() 	| 
		ForceNewline()	| 
		Title()			|
		MainTitle()		|
		MainMainTitle()	|
		List()			|
		Hrule()			|
		Link()			|
		Table()
	)+
}

void Bold() : {} 
{
	(
		<TITLE_BOLD>	| 
		<BOLD>			| 
		<NOTAGS_BOLD>	| 
		<LIST_BOLD>		| 
		<TABLE_BOLD>
	) 
	(
		Text() | ForceNewline() | Italic() | Underline()
	)+
	(
		<TITLE_BOLD>	| 
		<NOTAGS_BOLD>	| 
		<LIST_BOLD>		| 
		<TABLE_BOLD>
	)
}

void Italic() : {}
{
	(
		<TITLE_ITALIC>	| 
		<ITALIC> 		| 
		<NOTAGS_ITALIC> | 
		<LIST_ITALIC>	| 
		<TABLE_ITALIC>
	) 
	(
		Text() | ForceNewline() | Bold() | Underline()
	)+
	(
		<TITLE_ITALIC>	| 
		<NOTAGS_ITALIC> | 
		<LIST_ITALIC>	| 
		<TABLE_ITALIC>
	)
} 

void Underline() : {}
{
	(
		<TITLE_UNDERLINE>	| 
		<UNDERLINE>			| 
		<NOTAGS_UNDERLINE>	| 
		<LIST_UNDERLINE>	| 
		<TABLE_UNDERLINE>
	) 
	(
		Text() | ForceNewline() | Italic()| Bold()
	)+
	(
		<TITLE_UNDERLINE>	|
		<NOTAGS_UNDERLINE>	| 
		<LIST_UNDERLINE>	| 
		<TABLE_UNDERLINE>
	)
}

/** Link */

void Link() : 
{
	String textStr = null;
	String linkStr = "";	
}
{
	<LINK> 
	(
		LOOKAHEAD(2)
		textStr = Text()
		{
			linkStr += textStr;
		}
	)+ 
	{ 
		jjtThis.setOption("value", linkStr);
	}
	[ 
		LinkLabel()
	] 
	<LINK_END>
	<LINK_EOL>
}

void LinkLabel() : {}
{
	<LINK_SEPARATOR> 
	(
		LOOKAHEAD(2)
		Text()
	)+	
}


/** Table */

void Table() : {}
{
	(
		LOOKAHEAD(2) 
		TableRow()
	)+ 
}

void TableRow(): {}
{
	(
		LOOKAHEAD(2) 
		TableCol()
	)+ 	
	<TABLE_TABLE> <TABLE_EOL>	
}

void TableCol() : {}
{
	(
		<TABLE> | 
		<TABLE_TABLE>
	) 
	(
		LOOKAHEAD(2) 
		Text()		| 
		Bold()		| 
		Italic()	| 
		Underline()
	)+ 
}


/** List */

void List() : 
{
	int listDepth = 1;
}
{
	<LIST> 
	[
		LOOKAHEAD(2) 
		(
			<LIST_LIST> { listDepth += 1; }
		)+
	] 
	(
		LOOKAHEAD(2)
		Text()			|
		ForceNewline()	| 
		Bold()			| 
		Italic()		| 
		Underline()
	)+
	<LIST_EOL>
	{ jjtThis.setOption("depth", listDepth); }
}

/** Plaintext */

void Plain() : 
{
	Token t;
	String textStr = null;
	String plainStr = "";	
}
{
	<START_PLAIN> 
	(
		LOOKAHEAD(2) 
		textStr = PlainText()
		{
			plainStr += textStr;	
		}
	)* 
	{ 
		jjtThis.setOption("value", plainStr);
	}
	<END_PLAIN>	
}

String PlainText() : 
{
	Token t;	
}
{
	t = <PLAIN_ANY_CHAR>	{ jjtThis.setOption("value", t.image); } 		
	{
		return t.image;	
	}
}

/** Horizontal Rule */

void Hrule() : {}
{
	<HRULE>	
}

/** Titles (Main, MainMain and Title */

void Title() : {}
{
	<TITLE> 
	(
		LOOKAHEAD(2)
		Text()			|
		ForceNewline()	| 
		Bold()			| 
		Italic()		| 
		Underline()
	)+
	<TITLE_EOL>
}

void MainTitle() : {}
{
	<MAINTITLE> 
	(
		LOOKAHEAD(2)
		Text()			|
		ForceNewline()	| 
		Bold()			| 
		Italic()		| 
		Underline()
	)+
	<TITLE_EOL>
}

void MainMainTitle() : {}
{
	<MAINMAINTITLE> 
	(
		LOOKAHEAD(2)
		Text()			|
		ForceNewline()	| 
		Bold()			| 
		Italic()		| 
		Underline()
	)+
	<TITLE_EOL>
}


/** State spanning actions */

String Text() : 
{
	Token t;
}
{
	(
		t = <NOTAGS_ANY_CHAR>	{ jjtThis.setOption("value", t.image); } |
		t = <LIST_ANY_CHAR>		{ jjtThis.setOption("value", t.image); } | 
		t = <TITLE_ANY_CHAR>	{ jjtThis.setOption("value", t.image); } | 
		t = <TABLE_ANY_CHAR>	{ jjtThis.setOption("value", t.image); } |
		t = <LINK_ANY_CHAR>		{ jjtThis.setOption("value", t.image); } |	
		t = <ANY_CHAR>			{ jjtThis.setOption("value", t.image); } 		
	)
	{ 
		return t.image; 
	}
}

void ForceNewline() : {}
{
	<TITLE_FORCE_NEWLINE>	| 
	<NOTAGS_FORCE_NEWLINE>	| 
	<LIST_FORCE_NEWLINE>	|
	<TABLE_FORCE_NEWLINE>	|
	<FORCE_NEWLINE>	
}